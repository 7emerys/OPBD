import numpy as np
import matplotlib.pyplot as plt


# Функция для многоканальной системы с отказами
def multi_channel_system(num_channels, arrival_rate, service_rate, simulation_time):
    # Параметры
    lambda_ = arrival_rate  # Средняя скорость поступления заявок
    mu = service_rate  # Средняя скорость обслуживания
    rho = lambda_ / (num_channels * mu)  # Интенсивность загрузки системы

    # Инициализируем массив вероятностей нахождения в состоянии
    P = np.zeros(num_channels + 1)

    # Вычисление вероятности нахождения системы в пустом состоянии
    # p_0 = 1 / (1 + (rho * (1 - (rho ** num_channels)) / (1 - rho)))
    P[0] = 1 / (1 + (rho * (1 - (rho ** num_channels)) / (1 - rho)))

    # Вычисление вероятностей P[n] для каждого состояния n = 0, 1, ..., num_channels
    for n in range(1, num_channels + 1):
        P[n] = (rho ** n) * P[0]  # Вероятность нахождения в состоянии n

    # Нормализация вероятностей: сумма всех вероятностей должна быть равна 1
    P /= np.sum(P)

    # Результаты
    prob_reject = P[num_channels]  # Вероятность отказа (максимальное количество клиентов занято)
    avg_clients = np.sum(np.arange(num_channels + 1) * P)  # Среднее число клиентов в системе
    # Вычисление средней длины очереди, используя формулу для многоканальных систем
    avg_queue_length = max(0, (lambda_ ** 2) / (mu * (num_channels * mu - lambda_)))  # При наличии клиентов
    avg_busy_channels = np.sum(np.arange(1, num_channels + 1) * P[1:])  # Среднее число занятых каналов

    # Вывод результатов
    print("Многоканальная система с отказами")
    print(f"Вероятности нахождения в системе: {P}")
    print(f"Вероятность отказа: {prob_reject:.4f}")
    print(f"Среднее число обслуживаемых заявок: {avg_clients:.4f}")
    print(f"Средняя длина очереди: {avg_queue_length:.4f}")
    print(f"Среднее количество занятых каналов: {avg_busy_channels:.4f}\n")

    return P


# Функция для одноканальной системы с неограниченной очередью
def single_channel_unlimited_queue(arrival_rate, service_rate):
    lambda_ = arrival_rate  # Средняя скорость поступления заявок
    mu = service_rate  # Средняя скорость обслуживания
    rho = lambda_ / mu  # Интенсивность загрузки системы

    # Расчет вероятности нахождения системы в пустом состоянии
    P0 = 1 - rho  # Вероятность, что система свободна
    # Вероятности P[n] для состояния n = 0, 1, 2, ... (до 100)
    P = [P0 * (rho ** n) for n in range(0, 100)]

    # Результаты
    prob_reject = rho  # В одноканальной системе вероятность отказа равна интенсивности загрузки
    avg_clients = lambda_ / (mu - lambda_)  # Среднее число клиентов, обслуживаемых в системе
    avg_queue_length = (lambda_ ** 2) / (mu * (mu - lambda_))  # Средняя длина очереди
    avg_time_in_system = 1 / (mu - lambda_)  # Среднее время пребывания клиента в системе
    avg_time_in_queue = avg_queue_length / lambda_  # Среднее время ожидания клиента в очереди

    # Вывод результатов
    print("Одноканальная система с неограниченной очередью")
    print(f"Вероятности нахождения в системе: {P}")
    print(f"Вероятность отказа: {prob_reject:.4f}")
    print(f"Среднее число обслуживаемых заявок: {avg_clients:.4f}")
    print(f"Средняя длина очереди: {avg_queue_length:.4f}")
    print(f"Среднее время пребывания заявки в системе: {avg_time_in_system:.4f}")
    print(f"Среднее время пребывания заявки в очереди: {avg_time_in_queue:.4f}\n")

    return P


# Основная функция для запуска симуляции
def main():
    simulation_time = 1000  # Время симуляции (не используется в текущей версии, но можно добавить для расширения)

    # Параметры многоканальной системы с отказами
    num_channels = 3  # Количество обслуживающих каналов
    arrival_rate = 4  # Средняя скорость поступления заявок
    service_rate = 5  # Средняя скорость обслуживания

    # Вызываем функцию для многоканальной системы
    P_multi = multi_channel_system(num_channels, arrival_rate, service_rate, simulation_time)

    # Параметры одноканальной системы с неограниченной очередью
    arrival_rate_single = 4  # Средняя скорость поступления заявок
    service_rate_single = 5  # Средняя скорость обслуживания
    # Вызов функцию для одноканальной системы
    P_single = single_channel_unlimited_queue(arrival_rate_single, service_rate_single)

    # Визуализация результатов
    plt.figure(figsize=(12, 5))

    # График для многоканальной системы
    plt.subplot(1, 2, 1)
    plt.bar(range(len(P_multi)), P_multi)
    plt.title("Вероятности нахождения в многоканальной системе")
    plt.xlabel("Состояние")
    plt.ylabel("Вероятность")

    # График для одноканальной системы
    plt.subplot(1, 2, 2)
    plt.bar(range(len(P_single)), P_single)
    plt.title("Вероятности нахождения в одноканальной системе")
    plt.xlabel("Состояние")
    plt.ylabel("Вероятность")

    plt.tight_layout()  # Подгоняет подложку графиков
    plt.show()  # Отображает графики

if __name__ == "__main__":
    main()



#Функция multi_channel_system:
#     Параметры num_channels, arrival_rate и service_rate описывают многоканальную систему.
#     Используемый массив P хранит вероятности нахождения системы в разных состояниях: от 0 до num_channels.
#     Вероятность отказа вычисляется как вероятность того, что все каналы заняты.
#     Средняя длина очереди и среднее количество занятых каналов рассчитываются по формулам, которые используют параметры системы.
#
#Функция single_channel_unlimited_queue:
#     Здесь рассматривается одноканальная система с неограниченной очередью.
#     Здесь вероятность отказа равна интенсивности загрузки системы (rho), так как в одноканальной системе с неограниченной очередью заявки могут поступать, даже если агент занят.
#
#Визуализация:
#     Используется библиотека matplotlib для отображения вероятностей в виде гистограмм.
#     Графики показывают, как вероятность нахождения системы в том или ином состоянии изменяется в зависимости от нагрузки.
